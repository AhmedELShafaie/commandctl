#!/bin/bash

# -daystart   Measure times (for -amin, -atime, -cmin, -ctime, -mmin, and -mtime)  from the beginning of today rather than from 24 hours ago.
# This option only affects tests which appear later on the command line.
# -regextype type  Changes  the  regular  expression syntax understood by
# -regex and -iregex tests which occur later on the command line.
# To see which regular expression types are known, use
# -regextype help.
# The Texinfo documentation (see SEE ALSO) explains the meaning of and differences between the various types of regular expression.
# -warn, -nowarn Turn warning messages  on or off These warnings apply only to the command line usage,
# not to any conditions that find might encounter when it searches directories
# . The default behaviour corresponds to -warn if standard input is a tty,
# and to
# -nowarn  otherwise. If a warning message relating to command-line usage is produced,
# the exit status of find is not affected. If the POSIXLY_CORRECT environment variable is set,
# and -warn is also used, it is not specified which, if any,
# -d  A synonym for -depth, for compatibility with FreeBSD, NetBSD, MacOS X and OpenBSD.
# -depth    Process each directory's contents before the directory itself. The
# -delete   action also implies
# -depth    If the whole expression contains no actions other than -prune or -print,
# -print    is performed on all files  for  which the  whole expression is true.
# -newer-newerXY, -anewer -path pattern
# File name matches shell pattern pattern.
# The metacharacters do not treat `/' or `.' specially; so, for example, find . -path "./sr*sc"
# will print an entry for a directory called `./src/misc' (if one exists). To ignore a whole directory tree, use -prune
# under it, and print the names of the other files found, do something like this: find . -path ./src/emacs -prune -o -print
# Note that the pattern match test applies to the whole file name, starting from one of the start points named on the com‚Äê
# mand line. It would only make sense to use an absolute path name here if the relevant start point is also an absolute
# path. This means that this command will never match anything:
#     find bar -path /foo/bar/myfile -print
# Find compares the -path argument with the concatenation of a directory name and the base name of the file it's examining.
# Since the concatenation will never end with a slash, -path arguments ending in a slash will match nothing (except  perhaps
# a start point specified  on  the command line).  The predicate -path is also supported by HP-UX find and is part of the
# POSIX 2008 standard.
# -size n[cwbkMG]   File uses n units of space, rounding up.  The following suffixes can be used:
# `b'               for 512-byte blocks (this is the default if no suffix is used)
# `c'               for bytes
# `w'               for two-byte words
# `k'               for Kibibytes (KiB, units of 1024 bytes)
# `M'               for Mebibytes (MiB, units of 1024 * 1024 = 1048576 bytes)
# `G'               for Gibibytes (GiB, units of 1024 * 1024 * 1024 = 1073741824 bytes)


# SHORTCUT FOR FIND COMMAND

_find () {
    SEARCH=${1:-*}
    BASEPATH=${2:-.}
    # -iname
    find $BASEPATH -regex "$SEARCH" -ls
}
alias f='_find'


#SHORTCUT FOR FIND COMMAND
_findgrep () {
  BASEPATH=${1:-.}
  SEARCH=${2:-*}
  PATTERN=${3:-SEARCH}
  find $BASEPATH -regex "$SEARCH" \
    -exec grep --color=always --extended-regexp \
    --ignore-case --with-filename \
    --after-context=0 --before-context=0 \
    "$PATTERN" {} \;
}
alias fgrep='_findgrep'
alias f.grep='_findgrep'


#FIND STRINGS IN FILES
find_here() {
    find="$1"
    find . -iname $find -ls "{}" \;
}


#FIND A PATTERN IN FILES FOUND FROM DATE
find_in_from () {
    PATTERN=$1
    sudo find /var/log/ -ctime -2 -type f -readable -exec grep --color=auto -ir -e "$1" -- {} \;
}


#SHORTCUT FOR FIND COMMAND
_findcat () {
    BASEPATH=${1:-.}
    SEARCH=${2:-*}
    find $BASEPATH -regex "$SEARCH" -exec cat {} \;
}
alias fcat='_findcat'




#FIND AND TRIM BINARY CHARACTERS FROM FILES
trim_bin_chars () {
  cat "$1" | tr -cd '\11\12\40-\176'
  print "\n" \;
}


find_in_binary () {
   find ./ -type f -printf '%p' -exec cat {} \; | tr -cd '\11\12\40-\176'  | grep -i btc
}



#GRAB ALL THINGS IN PATH
grab () {
  TARGET="$1"
  find . -iname $TARGET \;
}


#EXECUTE A COMMAND ON LIST OF FILES AGAINST A PATTERN
find_exec() {
  find ./ -type f -iname '${1}' -exec "${@:2}"  {} \; ;

}


#FIND STINGS IN FILES
#find string in files in path
#  find <toys> in <./closet>
find_this_in_there() {
   WHAT=$1
   WHERE=${2:-./}
  cmd='find $WHERE -exec grep --ignore-case --color --with-filename --extended-regexp $WHAT "{}" \;'
  $cmd
}



#find string in files in path when filter (optional)
function find_this_in_there_when() {
  WHAT=$1
  WHERE=${2:-./}
  WHEN=${3:-}
  cmd="find $WHERE -iname $WHEN -exec grep --ignore-case --color --with-filename --extended-regexp $WHAT \"{}\" \;"
  command $cmd
}
